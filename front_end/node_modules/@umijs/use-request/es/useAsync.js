function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import debounce from 'lodash.debounce';
import throttle from 'lodash.throttle';
import { useCallback, useEffect, useRef, useState } from 'react';
import { isDocumentVisible } from './utils';
import { getCache, setCache } from './utils/cache';
import limit from './utils/limit';
import usePersistFn from './utils/usePersistFn';
import useUpdateEffect from './utils/useUpdateEffect';
import subscribeFocus from './utils/windowFocus';
import subscribeVisible from './utils/windowVisible';
var DEFAULT_KEY = 'UMIJS_USE_API_DEFAULT_KEY';

var Fetch = /*#__PURE__*/function () {
  // 请求时序
  // 是否卸载
  // visible 后，是否继续轮询
  function Fetch(service, config, subscribe, initState) {
    _classCallCheck(this, Fetch);

    this.config = void 0;
    this.service = void 0;
    this.count = 0;
    this.unmountedFlag = false;
    this.pollingWhenVisibleFlag = false;
    this.pollingTimer = undefined;
    this.loadingDelayTimer = undefined;
    this.subscribe = void 0;
    this.unsubscribe = [];
    this.that = this;
    this.state = {
      loading: false,
      params: [],
      data: undefined,
      error: undefined,
      run: this.run.bind(this.that),
      mutate: this.mutate.bind(this.that),
      refresh: this.refresh.bind(this.that),
      cancel: this.cancel.bind(this.that),
      unmount: this.unmount.bind(this.that)
    };
    this.debounceRun = void 0;
    this.throttleRun = void 0;
    this.limitRefresh = void 0;
    this.service = service;
    this.config = config;
    this.subscribe = subscribe;

    if (initState) {
      this.state = _objectSpread({}, this.state, {}, initState);
    }

    this.debounceRun = this.config.debounceInterval ? debounce(this._run, this.config.debounceInterval) : undefined;
    this.throttleRun = this.config.throttleInterval ? throttle(this._run, this.config.throttleInterval) : undefined;
    this.limitRefresh = limit(this.refresh.bind(this), this.config.focusTimespan);

    if (this.config.pollingInterval) {
      this.unsubscribe.push(subscribeVisible(this.rePolling.bind(this)));
    }

    if (this.config.refreshOnWindowFocus) {
      this.unsubscribe.push(subscribeFocus(this.limitRefresh.bind(this)));
    }
  }

  _createClass(Fetch, [{
    key: "setState",
    value: function setState() {
      var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.state = _objectSpread({}, this.state, {}, s);
      this.subscribe(this.state);
    }
  }, {
    key: "_run",
    value: function _run() {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // 取消已有定时器
      if (this.pollingTimer) {
        clearTimeout(this.pollingTimer);
      } // 取消 loadingDelayTimer


      if (this.loadingDelayTimer) {
        clearTimeout(this.loadingDelayTimer);
      }

      this.count += 1; // 闭包存储当次请求的 count

      var currentCount = this.count;
      this.setState({
        loading: !this.config.loadingDelay,
        params: args
      });

      if (this.config.loadingDelay) {
        this.loadingDelayTimer = setTimeout(function () {
          _this.setState({
            loading: true
          });
        }, this.config.loadingDelay);
      }

      return this.service.apply(this, args).then(function (res) {
        if (!_this.unmountedFlag && currentCount === _this.count) {
          if (_this.loadingDelayTimer) {
            clearTimeout(_this.loadingDelayTimer);
          }

          var formattedResult = _this.config.formatResult ? _this.config.formatResult(res) : res;

          _this.setState({
            data: formattedResult,
            error: undefined,
            loading: false
          });

          if (_this.config.onSuccess) {
            _this.config.onSuccess(formattedResult, args);
          }

          return formattedResult;
        }
      }).catch(function (error) {
        if (!_this.unmountedFlag && currentCount === _this.count) {
          if (_this.loadingDelayTimer) {
            clearTimeout(_this.loadingDelayTimer);
          }

          _this.setState({
            data: undefined,
            error: error,
            loading: false
          });

          if (_this.config.onError) {
            _this.config.onError(error, args);
          }

          console.error(error);
          return error; // throw error;
        }
      }).finally(function () {
        if (!_this.unmountedFlag && currentCount === _this.count) {
          if (_this.config.pollingInterval) {
            // 如果屏幕隐藏，并且 !pollingWhenHidden, 则停止轮询，并记录 flag，等 visible 时，继续轮询
            if (!isDocumentVisible() && !_this.config.pollingWhenHidden) {
              _this.pollingWhenVisibleFlag = true;
              return;
            }

            _this.pollingTimer = setTimeout(function () {
              _this._run.apply(_this, args);
            }, _this.config.pollingInterval);
          }
        }
      });
    }
  }, {
    key: "run",
    value: function run() {
      if (this.debounceRun) {
        this.debounceRun.apply(this, arguments); // TODO 如果 options 存在 debounceInterval，或 throttleInterval，则 run 和 refresh 不会返回 Promise。 带类型需要修复后，此处变成 return;。

        return Promise.resolve(null);
      }

      if (this.throttleRun) {
        this.throttleRun.apply(this, arguments);
        return Promise.resolve(null);
      }

      return this._run.apply(this, arguments);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (this.debounceRun) {
        this.debounceRun.cancel();
      }

      if (this.throttleRun) {
        this.throttleRun.cancel();
      }

      if (this.loadingDelayTimer) {
        clearTimeout(this.loadingDelayTimer);
      }

      if (this.pollingTimer) {
        clearTimeout(this.pollingTimer);
      }

      this.pollingWhenVisibleFlag = false;
      this.count += 1;
      this.setState({
        loading: false
      });
    }
  }, {
    key: "refresh",
    value: function refresh() {
      return this.run.apply(this, _toConsumableArray(this.state.params));
    }
  }, {
    key: "rePolling",
    value: function rePolling() {
      if (this.pollingWhenVisibleFlag) {
        this.pollingWhenVisibleFlag = false;
        this.refresh();
      }
    }
  }, {
    key: "mutate",
    value: function mutate(data) {
      if (typeof data === 'function') {
        this.setState({
          // eslint-disable-next-line react/no-access-state-in-setstate
          data: data(this.state.data) || {}
        });
      } else {
        this.setState({
          data: data
        });
      }
    }
  }, {
    key: "unmount",
    value: function unmount() {
      this.unmountedFlag = true;
      this.cancel();
      this.unsubscribe.forEach(function (s) {
        s();
      });
    }
  }]);

  return Fetch;
}();

function useAsync(service, options) {
  var _options = options || {};

  var _options$refreshDeps = _options.refreshDeps,
      refreshDeps = _options$refreshDeps === void 0 ? [] : _options$refreshDeps,
      _options$manual = _options.manual,
      manual = _options$manual === void 0 ? false : _options$manual,
      _options$onSuccess = _options.onSuccess,
      onSuccess = _options$onSuccess === void 0 ? function () {} : _options$onSuccess,
      _options$onError = _options.onError,
      onError = _options$onError === void 0 ? function () {} : _options$onError,
      _options$defaultLoadi = _options.defaultLoading,
      defaultLoading = _options$defaultLoadi === void 0 ? false : _options$defaultLoadi,
      loadingDelay = _options.loadingDelay,
      _options$pollingInter = _options.pollingInterval,
      pollingInterval = _options$pollingInter === void 0 ? 0 : _options$pollingInter,
      _options$pollingWhenH = _options.pollingWhenHidden,
      pollingWhenHidden = _options$pollingWhenH === void 0 ? true : _options$pollingWhenH,
      _options$defaultParam = _options.defaultParams,
      defaultParams = _options$defaultParam === void 0 ? [] : _options$defaultParam,
      _options$refreshOnWin = _options.refreshOnWindowFocus,
      refreshOnWindowFocus = _options$refreshOnWin === void 0 ? false : _options$refreshOnWin,
      _options$focusTimespa = _options.focusTimespan,
      focusTimespan = _options$focusTimespa === void 0 ? 5000 : _options$focusTimespa,
      fetchKey = _options.fetchKey,
      cacheKey = _options.cacheKey,
      debounceInterval = _options.debounceInterval,
      throttleInterval = _options.throttleInterval,
      initialData = _options.initialData;
  var newstFetchKey = useRef(DEFAULT_KEY); // 持久化一些函数

  var servicePersist = usePersistFn(service);
  var onSuccessPersist = usePersistFn(onSuccess);
  var onErrorPersist = usePersistFn(onError);
  var fetchKeyPersist = usePersistFn(fetchKey);
  var formatResult;

  if ('formatResult' in _options) {
    // eslint-disable-next-line prefer-destructuring
    formatResult = _options.formatResult;
  }

  var formatResultPersist = usePersistFn(formatResult);
  var config = {
    formatResult: formatResultPersist,
    onSuccess: onSuccessPersist,
    onError: onErrorPersist,
    loadingDelay: loadingDelay,
    pollingInterval: pollingInterval,
    pollingWhenHidden: pollingWhenHidden,
    refreshOnWindowFocus: refreshOnWindowFocus,
    focusTimespan: focusTimespan,
    debounceInterval: debounceInterval,
    throttleInterval: throttleInterval
  };
  var subscribe = usePersistFn(function (key, data) {
    setFeches(function (s) {
      // eslint-disable-next-line no-param-reassign
      s[key] = data;
      return _objectSpread({}, s);
    });
  }, []);

  var _useState = useState(function () {
    // 如果有 缓存，则从缓存中读数据
    if (cacheKey) {
      var cache = getCache(cacheKey);

      if (cache) {
        newstFetchKey.current = cache.newstFetchKey;
        /* 使用 initState, 重新 new Fetch */

        var newFetches = {};
        Object.keys(cache.fetches).forEach(function (key) {
          var cacheFetch = cache.fetches[key];
          var newFetch = new Fetch(servicePersist, config, subscribe.bind(null, key), {
            loading: cacheFetch.loading,
            params: cacheFetch.params,
            data: cacheFetch.data,
            error: cacheFetch.error
          });
          newFetches[key] = newFetch.state;
        });
        return newFetches;
      }
    }

    return [];
  }),
      _useState2 = _slicedToArray(_useState, 2),
      fetches = _useState2[0],
      setFeches = _useState2[1];

  var fetchesRef = useRef(fetches);
  fetchesRef.current = fetches;
  var run = useCallback(function () {
    var _currentFetch;

    if (fetchKeyPersist) {
      var key = fetchKeyPersist.apply(void 0, arguments);
      newstFetchKey.current = key === undefined ? DEFAULT_KEY : key;
    }

    var currentFetchKey = newstFetchKey.current; // 这里必须用 fetchsRef，而不能用 fetches。
    // 否则在 reset 完，立即 run 的时候，这里拿到的 fetches 是旧的。

    var currentFetch = fetchesRef.current[currentFetchKey];

    if (!currentFetch) {
      var newFetch = new Fetch(servicePersist, config, subscribe.bind(null, currentFetchKey), {
        data: initialData
      });
      currentFetch = newFetch.state;
      setFeches(function (s) {
        // eslint-disable-next-line no-param-reassign
        s[currentFetchKey] = currentFetch;
        return _objectSpread({}, s);
      });
    }

    return (_currentFetch = currentFetch).run.apply(_currentFetch, arguments);
  }, [fetchKey, subscribe]); // cache

  useEffect(function () {
    if (cacheKey) {
      setCache(cacheKey, {
        fetches: fetches,
        newstFetchKey: newstFetchKey.current
      });
    }
  }, [cacheKey, fetches]); // 第一次默认执行

  useEffect(function () {
    if (!manual) {
      // 如果有缓存
      if (Object.keys(fetches).length > 0) {
        /* 重新执行所有的 */
        Object.values(fetches).forEach(function (f) {
          f.refresh();
        });
      } else {
        // 第一次默认执行，可以通过 defaultParams 设置参数
        run.apply(void 0, _toConsumableArray(defaultParams));
      }
    }
  }, []); // 重置 fetches

  var reset = useCallback(function () {
    Object.values(fetchesRef.current).forEach(function (f) {
      f.unmount();
    });
    newstFetchKey.current = DEFAULT_KEY;
    setFeches({}); // 不写会有问题。如果不写，此时立即 run，会是老的数据

    fetchesRef.current = {};
  }, [setFeches]); //  refreshDeps 变化，重新执行所有请求

  useUpdateEffect(function () {
    if (!manual) {
      /* 全部重新执行 */
      Object.values(fetchesRef.current).forEach(function (f) {
        f.refresh();
      });
    }
  }, _toConsumableArray(refreshDeps)); // 卸载组件触发

  useEffect(function () {
    return function () {
      Object.values(fetchesRef.current).forEach(function (f) {
        f.unmount();
      });
    };
  }, []);
  var noReady = useCallback(function (name) {
    return function () {
      throw new Error("Cannot call ".concat(name, " when service not executed once."));
    };
  }, []);
  return _objectSpread({
    loading: !manual || defaultLoading,
    data: initialData,
    error: undefined,
    params: [],
    cancel: noReady('cancel'),
    refresh: noReady('refresh'),
    mutate: noReady('mutate')
  }, fetches[newstFetchKey.current] || {}, {
    run: run,
    fetches: fetches,
    reset: reset
  });
}

export default useAsync;